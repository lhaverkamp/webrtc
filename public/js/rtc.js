var defaultConfig = {
	// simple constraints for the defaults
	constraints: {
		video: { frameRate: 10 },
		audio: true
	},
		
	// specify the location of the signalling server
	signaller: 'wss://' + location.hostname + ':3000',
	
    // room defined by default
	room: null,
		
	// specify ice servers
	ice: [
	      { url: "stun:stun.l.google.com:19302" }
	],

	// data channel configuration
	channels: {
		chat: true,
		optional: [
		    { DtlsSrtpKeyAgreement: true },
		    { RtcDataChannels: true } // most examples show RtpDataChannels but that appears to be an invalid argument
		]
	},
		
	// the selector that will be used to identify the local video container
	localContainer: '.video-container',
		
	// the selector that will be used to identify the remote video container
	remoteContainer: '.video-container',
	
	// styling options
	options: {
		controls: {
			audio: { 
				enabled: 'fa-microphone',
				disabled: 'fa-microphone-slash'
			},
			video: {
				enabled: 'fa-eye',
				disabled: 'fa-eye-slash'
			},
			frameRate: {
				min: 10,
				max: 60,
				step: 10
			}
		}
	}
};

/**
 * This is the Rtc class that encapsulates all of the WebRTC logic.  It takes
 * in a config object that will determine basic options on how the service
 * will be initialized.
 * 
 * @param config an array of configuration options
 */
var Rtc = function(config) {
	// identifier
	this.id = null;
	// reference to localStream
	this.localStream = null;
	// array of connected peers
	this.peers = {};
	// array of channels
	this.channels = {};
	
	// connect to the signaling server
	this.signaller = this.connect(config);
	
	// if we have constraints, then capture video
	if(config.constraints) {
		this.localVideo(this.signaller, config);
	}
};

/**
 * This method connects to the signalling server and sets up handling of each
 * of the signals that are handled on the client.
 * 
 * @param config an array of configuration options
 * 
 * @return the signaller
 */
Rtc.prototype.connect = function(config) {
	// create signaling server
	var socket = io(config.signaller);
	
	// handle socket events
	socket.on('connect', this.handleConnect(socket, config));
	socket.on('reconnect', this.handleReconnect(socket, config));
	
	// handle signals
	socket.on('peer:announce', this.handleAnnounce(socket, config));
	socket.on('peer:update', this.handleUpdate(socket, config));
	socket.on('peer:call', this.handleCall(socket, config));
	socket.on('peer:accept', this.handleAccept(socket, config));
	socket.on('peer:ice', this.handleIce(socket, config));
	socket.on('peer:disconnect', this.handleDisconnect(socket, config));

	return socket;
};

/**
 * This event is triggered upon connecting to the signalling server.
 * 
 * @param socket the signalling server connection
 * @param config an array of configuration options
 * 
 * @returns {Function} the event handler
 */
Rtc.prototype.handleConnect = function(socket, config) {
	var _this = this;
	
	return function(data) {
		console.log('connect');
		
		_this.id = socket.id;
	}
};

/**
 * This event is triggered upon reconnecting to the signalling server.
 * 
 * @param socket the signalling server connection
 * @param config an array of configuration options
 * 
 * @returns {Function} the event handler
 */
Rtc.prototype.handleReconnect = function(socket, config) {
	var _this = this;
	
	return function(data) {
		console.log('reconnect');
		
		socket.emit('update', { room: config.room, peerId: _this.id });
		_this.id = socket.id; // store new id
	}
};

/**
 * This function generates the event handler for the peer:announce event.  Such
 * an event is generated by the signalling server whenever a new client joins
 * an existing room.
 * 
 * 1.  creates an RTCPeerConnection object
 * 2.  creates an SDP offer
 * 3.  sets the local description associated with the connection
 * 4.  sends the offer via the signalling server
 * 
 * @param socket the signalling server connection
 * @param config configuration options
 * 
 * @returns {Function} the event handler
 */
Rtc.prototype.handleAnnounce = function(socket, config) {
	var _this = this;
	
	// closure to ensure the correct scope for the event listener
	return function(data) {
		// create RTCPeerConnection
		var pc = _this.createPeerConnection(data.peerId, socket, config);
		var dc = _this.createDataChannel(data.peerId, pc, config);
		
		pc.createOffer().then(function(offer) {
			return pc.setLocalDescription(offer);
		}).then(function() {
			socket.emit('peer:call', { 'from': socket.id, 'to': data.peerId, 'sdp' : pc.localDescription });
		}).catch(_this.handleError);
	}
};

/**
 * This function generates the event handler for the peer:update event.  Such
 * an event is generated by the signalling server whenever a client reconnects.
 * 
 * @param socket the signalling server connection
 * @param config an array of configuration options
 * 
 * @returns {Function} the event handler
 */
Rtc.prototype.handleUpdate = function(socket, config) {
	var _this = this;
	
	return function(data) {
		console.log('peer:update');
		// a possible alternative may be to use the 
		// RTCPeerConnection.peerIdentity property, although this would need
		// to be submitted to the signalling server
		var peerId = "/#" + data.peerId; // client and server have different ids
		var newPeerId = data.newPeerId;
		
		var peer = _this.peers[peerId];
		delete _this.peers[peerId];
		_this.peers[newPeerId] = peer;
		
		var channel = _this.channels[peerId];
		delete _this.channels[peerId];
		_this.channels[newPeerId] = peer;
		
		var node = document.querySelector('[data-peer="' + peerId + '"]');
		node.setAttribute('data-peer', newPeerId);
	}
};

/**
 * This function generates the event handler for the peer:call signal.  Such an
 * event is generated by remote peers responding to an sdp offer.
 * 
 * 1.  creates an RTCPeerConnection object
 * 2.  sets the remote description associated with the connection
 * 3.  creates an answer to the SDP offer
 * 4.  sets the local description associated with the connection
 * 5.  sends the answer via the signalling server
 * 
 * @param socket the signalling server connection
 * @param config an array of configuration options
 * 
 * @returns {Function} the event handler
 */
Rtc.prototype.handleCall = function(socket, config) {
	var _this = this;
	
	// closure to ensure the correct scope for the event listener
	return function(data) {
		var pc = _this.createPeerConnection(data.peerId, socket, config);
		
		console.log('setRemoteDescription');
		pc.setRemoteDescription(new RTCSessionDescription(data.sdp), function() {
			console.log('createAnswer');
			pc.createAnswer(function(answer) {
				console.log('setLocalDescription');
				pc.setLocalDescription(new RTCSessionDescription(answer), function() {
					// accept the call
					socket.emit('peer:accept', { 'from': socket.id, 'to': data.peerId, 'sdp' : answer });
				}, _this.handleError);
			}, _this.handleError);
		}, _this.handleError);
	}
};

/**
 * This functions generates the event handler for the peer:accept signal.  
 * Such an event is generated whenever a response is received for an sdp offer.
 * 
 * 1.  sets the remote description associated with the connection
 * 
 * @param socket the signalling server connection
 * @param config an array of configuration options
 * 
 * @returns {Function} the event handler
 */
Rtc.prototype.handleAccept = function(socket, config) {
	var _this = this;
	
	// closure to ensure the correct scope for the event listener
	return function(data) {
		// locates the RTCPeerConnection used when the offer was created
		var pc = _this.peers[data.peerId];
		
		if(pc) {
			new Promise(function(resolve, reject) {
				console.log('setRemoteDescription');
				pc.setRemoteDescription(new RTCSessionDescription(data.sdp), resolve, reject); // sessionDescription, successCallback, errorCallback
			})/* TODO .catch(_this.handleError) */;
		} else {
			_this.handleError("missing RTCPeerConnection for peer " + data.peerId);
		}
	}
};

/**
 * This function generates the event handler for the the peer:ice signal.  Such
 * an event is generated when a new ICE candidate arrives over the signalling 
 * channel.
 * 
 * @param socket the signalling server connection
 * @param config an array of configuration options
 * 
 * @returns {Function} the event handler
 */
Rtc.prototype.handleIce = function(socket, config) {
	var _this = this;
	
	// closure to ensure the correct scope for the event listener
	return function(data) {
		var pc = _this.peers[data.peerId];

		if(pc) {
			var candidate = new RTCIceCandidate(data.candidate);
			
			console.log('addIceCandidate');
			pc.addIceCandidate(candidate).catch(this.handleError);
		} else {
			_this.handleError("missing RTCPeerConnection for peer " + data.peerId);
		}
	}
};

/**
 * This function generates the event handler for the peer:disconnect signal.  
 * It removes the remote video element and removes the remote peer from the 
 * peer list.
 * 
 * @return the signal handling function
 */
Rtc.prototype.handleDisconnect = function() {
	var _this = this;
	
	return function(data) {
		console.log('peer:disconnect');
		var peerId = data.peerId;
		var nodes = document.querySelectorAll('[data-peer="' + peerId + '"]');
		
		// remove from remote video container
		for(var i=0;i<nodes.length;i++) {
			var el = nodes[i];
			el.parentNode.removeChild(el);
		}
		
		// remove from peer list
		delete _this.peers[peerId];
	}
};

/**
 * Creates and returns a new RTCPeerConnection object.
 * 
 * @param peerId the identifier of the peer we are connecting too
 * @param socket the signalling server used for initial peer communications
 * @param config the RTCConfiguration properties 
 * 
 * @return an RTCPeerConnection object
 */
Rtc.prototype.createPeerConnection = function(peerId, socket, config) {
	var servers = { 
		iceServers: ((config || {}).ice || defaultConfig.ice)
	};
	
	var constraints = {
		optional: (((config || {}).channels).optional) || defaultConfig.channels.optional
	};
	constraints = null;
	
	var pc = new RTCPeerConnection(servers, constraints);
	pc.onaddstream = this.handleAddStream(peerId, config);
	pc.ondatachannel = this.handleDataChannel(peerId, config);
	pc.onicecandidate = this.handleIceCandidate(peerId, socket);
	// oniceconnectionstatechange
	// onidentityresult
	// onidpasserionerror
	// onidpvalidationerror
	// onnegotiationneeded
	// onpeeridentity
	// onremovestream
	pc.onremovestream = this.handleRemoveStream(peerId, config);
	// onsignalingstatechange
	
	// add the local stream
	if(this.localStream) {
		pc.addStream(this.localStream);
	}
	
	// add the connection to the peer list
	this.peers[peerId] = pc;
	
	return pc;
};

/**
 * This function generates the event handler for the addstream event of a
 * RTCPeerConnection object.  Such an event is sent when a MediaStream is added 
 * to this connection by the remote peer. The event is sent immediately after 
 * the call RTCPeerConnection.setRemoteDescription() and doesn't wait for the 
 * result of the SDP negotiation.
 * 
 * @param @peerId the identifier of the remote peer
 * @param @socket the signalling server connection
 * 
 * @return the event handler
 */
Rtc.prototype.handleAddStream = function(peerId, config) {
	var _this = this;
	
	// closure to ensure the correct scope for the event listener
	return function(event) {
		var mediaStream = event.stream;
		
		var video = _this.attach(mediaStream, config.options);
		video.classList.add('video', 'remote-video'); // TODO configurable
		
		// override for remote audio
		var opts = { audio: { enabled: 'fa-volume-up', disabled: 'fa-volume-off' } }; // TODO configurable
		opts = Object.assign({}, ((config || defaultConfig).options || defaultConfig.options).controls, { controls: opts });
		var controls = _this.attachControls(mediaStream, opts.controls);
		
		var videoStreamContainer = document.createElement('div');
		videoStreamContainer.setAttribute('id', mediaStream.id);
		videoStreamContainer.setAttribute('data-peer', peerId);
		videoStreamContainer.classList.add('video-stream-container'); // TODO configurable
		videoStreamContainer.appendChild(video);
		videoStreamContainer.appendChild(controls);
		
		var remoteContainer = document.querySelector((config || {}).remoteContainer || R_VIDEO);
		remoteContainer.appendChild(videoStreamContainer);
	}
};

/**
 * This function generates the event handler for the datachannel event of a 
 * RTCPeerConnection object.  Such an event is sent when a RTCDataChannel is 
 * added to this connection.
 * 
 * @param peerId the identifier of the remote peer
 * @param config the signaling server connection
 * 
 * @return the event handler
 */
Rtc.prototype.handleDataChannel = function(peerId, config) {
	var _this = this;
	
	return function(event) {
		console.log("ondatachannel");
		
		var dc = event.channel;
		
		dc.onmessage = _this.handleMessage(peerId, config);
		dc.onopen = _this.handleOpen(peerId, config);
		dc.onclose = _this.handleClose(peerId, config);
		
		_this.channels[peerId] = dc;
	}
};

/**
 * This function generates the event handler for the icecandidate event of a
 * RTCPeerConnection object.  Such an event is sent when a RTCICECandidate 
 * object is added to the script.
 *  
 * @param peerId the identifier of the remote peer
 * @param socket the signalling server connection
 * 
 * @return the event handling function
 */
Rtc.prototype.handleIceCandidate = function(peerId, socket) {
	// closure to ensure the correct scope for the event listener
	return function(event) {
		if(event.candidate) {
			// sent to peer
			socket.emit('peer:candidate', { 'from': socket.id, 'to': peerId, 'candidate' : event.candidate });
		}
	}
};

Rtc.prototype.handleRemoveStream = function(peerId, socket) {
	// closure to ensure the correct scope for the event listener
	return function(event) {
		var mediaStream = event.stream;

		var el = document.getElementById(mediaStream.id);
		el.parentNode.removeChild(el);
	}
};

Rtc.prototype.createDataChannel = function(peerId, pc, config) {
	var options = {
		reliable: false // Chrome doesn't support reliable DataChannels
	}
	
	if(((config || {}).channels || {}).chat) {
		// create a data channel for chat based communication
		var dc = pc.createDataChannel('chat', options);
		dc.onopen = this.handleOpen(peerId, config);
		dc.onmessage = this.handleMessage(peerId, config);
		// dc.onbufferedamountlow =
		dc.onclose = this.handleClose(peerId, config);
		dc.onerror = this.handleError;
			
		this.channels[peerId] = dc;
	}
};

Rtc.prototype.handleOpen = function(peerId, config) {
	var _this = this;
	
	return function(event) {
		console.log("onopen");
	}
};

Rtc.prototype.handleClose = function(peerId, config) {
	return function(event) {
		console.log("onclose");
	}
};

Rtc.prototype.handleMessage = function(peerId, config) {
	var _this = this;
	
	return function(event) {
		console.log("onmessage");
		_this.attachMessage(event.data, config.options);
	}
};

/**
 * The generic error handler for the Rtc object.  It simply logs messages to
 * the console.
 */
Rtc.prototype.handleError = function(err) {
	console.log(err);
	console.log(err.stack);
};

/**
 * This function attaches a stream to a DOM element and returns the DOM element
 * to which it was attached.
 * 
 * @param mediaStream the stream to attach
 * @param options an array of options that contains information about if the
 * stream should be muted or an existing element should be used.
 * 
 * @return the Element to which the video was attached
 */
Rtc.prototype.attach = function(mediaStream, options) {
	var URL = typeof window != 'undefined' && window.URL;

	// allows for one parameter to be passed in
	if(typeof options == 'undefined') {
		options = {};
	}

	function applyModifications(el, options) {
		if((options || {}).muted) {
			el.muted = true;
			el.setAttribute('muted', '');
		}

		if((options || {}).mirror) {
	    	el.setAttribute('data-mirrored', true);
		}

		return el;
	}
	
	function attachToElement(mediaStream, options) {
		var autoplay = (options || {}).autoplay;
		var elType = 'audio';
		var el = (options || {}).el || (options || {}).target;

		// check the stream is valid
		var isValid = mediaStream && typeof mediaStream.getVideoTracks == 'function';

		// determine the element type
		if(isValid && mediaStream.getVideoTracks().length > 0) {
			elType = 'video';
		}

		// if we have been passed an "unplayable" target create a new element
		if(el && typeof el.play != 'function') {
			el = null;
		}

		// prepare the element
		el = el || document.createElement(elType);

		// attach the mediaStream
		if(URL && URL.createObjectURL) {
			el.src = URL.createObjectURL(mediaStream);
	    } else if(el.srcObject) {
	    	el.srcObject = mediaStream;
	    } else if(el.mozSrcObject) {
	    	el.mozSrcObject = mediaStream;
	    }

	    if(autoplay === undefined || autoplay) {
	    	el.setAttribute('autoplay', '');
	    	el.play();
	    }

	    return applyModifications(el, options);
	}
	
	return attachToElement(mediaStream, options);
};

/**
 * This function attaches a stream to a DOM element and returns the DOM element
 * to which it was attached.
 * 
 * @param mediaStream the stream to attach
 * @param options an array of options
 * 
 * @return the Element to which the video was attached
 */
Rtc.prototype.attachControls = function(mediaStream, options) {
	var _this = this;
	
	// allows for one parameter to be passed in
	if(typeof options == 'undefined') {
		options = defaultConfig.options.controls;
	}
	
	function attachToElement(mediaStream, options) {
		var audio = (options || defaultConfig.options.controls).audio;
		var video = (options || defaultConfig.options.controls).video;
		var frameRate = (options || defaultConfig.options.controls).frameRate;
		
		// <div class="video-controls">...</div>
		var el = document.createElement('div');
		el.classList.add('video-controls'); // TODO configurable
		
		if(audio) {
			var i = document.createElement("i");
			i.classList.add('fa', 'fa-2x', (audio || {}).enabled || defaultConfig.options.audio.enabled);

			var button = document.createElement("button");
			button.classList.add('button', 'audio-button'); // TODO configurable
			button.appendChild(i);
			button.addEventListener('click', _this.toggleAudio(mediaStream, options));
			
			el.appendChild(button);
		}
		
		if(video) {
			var i = document.createElement("i");
			i.classList.add('fa', 'fa-2x', (video || {}).enabled || defaultConfig.options.video.enabled);
			
			var button = document.createElement("button");
			button.classList.add('button', 'video-button'); // TODO configurable
			button.appendChild(i);
			button.addEventListener('click', _this.toggleVideo(mediaStream, options));
			
			el.appendChild(button);
		}
		
		// it appears that Chrome doesn't support applyConstraints to change
		// the frameRate on the fly
		if(frameRate && typeof window.MediaStreamTrack.prototype.applyConstraints == 'function') {
			var slider = document.createElement("input");
			slider.setAttribute('type', 'range');
			slider.setAttribute('min', (frameRate || {}).min || defaultConfig.options.frameRate.min);
			slider.setAttribute('max', (frameRate || {}).max || defaultConfig.options.frameRate.max);
			slider.setAttribute('step', (frameRate || {}).step || defaultConfig.options.frameRate.step);
			slider.classList.add('slider', 'slider-frame-rate'); // TODO configurable
			slider.addEventListener('change', _this.toggleFrameRate(mediaStream, options));
			
			el.appendChild(slider);
		}
		
		return el;
	}

	return attachToElement(mediaStream, options);
};

/**
 * This function attaches the local stream to a DOM element and returns the DOM
 * element to which it was attached.  The local stream is set to be muted.
 * 
 * @param stream the stream to attach
 * @param options an array of options
 * 
 * @return the Element to which the video was attached
 */
Rtc.prototype.attachLocal = function(mediaStream, options) {
	// allows for one parameter to be passed in
	if(typeof options == 'undefined') {
		options = {};
	}
	
	return this.attach(mediaStream, { muted: true, mirror: true });
}

/**
 * This function captures the local video, displays it on the page, and 
 * starts the conference.
 * 
 * @param socket the signalling server connection
 * @param config configuration options
 */
Rtc.prototype.localVideo = function(socket, config) {
	var _this = this;
	
	navigator.mediaDevices.getUserMedia(config.constraints)
	.then(function(mediaStream) {
		// store reference to local stream
		_this.localStream = mediaStream;
		
		for(var i=0;i<_this.peers.length;i++) {
			var peer = _this.peers[i];
			peer.addStream(mediaStream); // set local stream
		}
		
		// announce we are ready for conference
		socket.emit('announce', { room: config.room });
		
		return mediaStream;
	}).then(function(mediaStream) {
		// TODO consolidate options
		var video = _this.attach(mediaStream, { muted: true, mirror: true });
		video.classList.add('video', 'local-video'); // TODO configurable
		
		var controls = _this.attachControls(mediaStream, (config.options || defaultConfig.options).controls);
		
		var videoStreamContainer = document.createElement('div');
		videoStreamContainer.classList.add('video-stream-container'); // TODO configurable
		videoStreamContainer.appendChild(video);
		videoStreamContainer.appendChild(controls);

		var localContainer = document.querySelector((config || {}).localContainer || defaultConfig.localContainer);
		localContainer.insertBefore(videoStreamContainer, localContainer.childNodes[0]);
		
		return localContainer;
	})/* TODO.catch(this.handleError)*/;
};

/**
 * This function creates the event handler for the click event associated with
 * muting and unmuting audio.
 * 
 * @param stream the stream to manipulate
 * @param options the configuration options to use
 * 
 * @return the event handling function
 */
Rtc.prototype.toggleAudio = function(mediaStream, options) {
	var _this = this;
	var audio = (options || {}).audio;
	
	return function(event) {
		if(mediaStream) {
			var audioTracks = mediaStream.getAudioTracks();
		
			if(audioTracks[0]) {
				audioTracks[0].enabled = !audioTracks[0].enabled;
	
				var icon = event.currentTarget.querySelector("i"); 
				icon.classList.toggle((audio || {}).enabled || defaultConfig.options.audio.enabled);
				icon.classList.toggle((audio || {}).disabled || defaultConfig.options.audio.disabled);
				// fa-stack-1 fa-stack-2 fa-ban
			}
		}
	}
};

/**
 * This method creates the event handler for the click event associated with
 * enabling and disabling the video stream.
 * 
 * @param stream the stream to manipulate
 * @param options the configuration options to use
 * 
 * @return the event handling function
 */
Rtc.prototype.toggleVideo = function(mediaStream, options) {
	var _this = this;
	var video = (options || {}).video;
	
	return function(event) {
		if(mediaStream) {
			var videoTracks = mediaStream.getVideoTracks();
			
			if(videoTracks[0]) {
				videoTracks[0].enabled = !videoTracks[0].enabled;
	
				var icon = event.currentTarget.querySelector("i");
				icon.classList.toggle((video || {}).enabled || defaultConfig.options.video.enabled);
				icon.classList.toggle((video || {}).disabled || defaultConfig.options.video.disabled);
			}
		}
	}
};

Rtc.prototype.toggleFrameRate = function(mediaStream, options) {
	var _this = this;
	var opts = (options || {}).frameRate;
	
	return function(event) {
		if(mediaStream) {
			var videoTracks = mediaStream.getVideoTracks();
			
			if(videoTracks[0]) {
				videoTracks[0].applyConstraints({ frameRate: event.currentTarget.value })
				.error(this.handleError);
			}
		}
	}
};

Rtc.prototype.attachMessage = function(data, options) {
	var text = document.createTextNode(data);
	
	var div = document.createElement('div');
	div.classList.add('message'); // TODO configurable
	div.appendChild(text);

	var messageContainer = document.querySelector('.message-container');
	messageContainer.appendChild(div);
};

Rtc.prototype.sendMessage = function(mediaStream, options) {
	var _this = this;
	
	return function(event) {
		var input = document.querySelector('.chat-message');
		var message = input.value;
		input.value = null;
		
		if(message) {
			var keys = Object.keys(_this.channels);
			for(var i=0;i<keys.length;i++) {
				var key = keys[i];
				var dc = _this.channels[key];
				
				if(dc.readyState == 'open') {
					dc.send(message);
				} else {
					console.log("RTCDataChannel.readyState is not 'open'");
				}
			}
	
			_this.attachMessage(message, options);
		}
	}
};

var rtc = new Rtc(rtcOpts);

document.querySelector('.send-button').addEventListener('click', rtc.sendMessage(null, rtcOpts));
